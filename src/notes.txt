the app.html in the ./app dir is the main html code that runs when we load the application
app.ts is the part where the app.component.ts is being mapped to

the class's field entered in app.ts can be used by {{}} in app.html

file structure of the angular project:
1. entire project's config is stored in tsconfig.json. even build config is stored here
2. the config of the src dir is stored in tsconfig.app.json. the config during dev env is stored here
3. config of test cases written to test is stored in tsconfig.spec.json.
4. angular.json = project's config that which file be loaded first, then which html will be loaded first, output path is also mentioned here, assets are written here, config of project, app, TS, specs like production's max size etc are written here
5. package-lock.json = (auto created) stores exact versions of various dependencies
6. package.json = stores the basic version that which versions are allowed to run the application
7. .editorconfig = code formatting options, editor configs are written here like font style etc
8. .angular = used for caching
9. node_modules = all the packages, lib, dependencies are stored here
10. src = application's code is written here
11. index.html = first html file that is loaded (HTML's entry point)
12. main.ts = first TS file that runs (TS's entry point)
13. public = static images / assets are placed here that are publicly accessed

INTERPOLATION
the technique of taking data from TS file and putting in HTML file is called interpolation. using "{{}}" in HTML to process a variable in TS.
we can also write some direct code of TS into the {{}}

benefits of interpolation:
1. "DISPLAYING DATA FROM TS TO HTML FILE"
2. "EXECUTE JS CODE IN HTML FILE"

we can write some math expressions to inside {{}} and it will be processed and the ans will be shown in the HTML file.
variables written in app.ts can only be used in app.html
in app.ts we mention template url which tells which html file can be interpolated with TS file

limitations in interpolation:
1. new variable can't be assigneed in HTML file
2. increment and decrement ops can't be used
3. for,while can be used in HTML file

ANGULAR CLI
used to run, test, debug angular application
to check whether angular cli is installed: ng version
to create new project: ng new "app-name"
to create component using angular cli: ng generate component "component-name"
to create pipe: ng generate pipe "pipe-name"
all the components / pipes are created in the ./src/app dir
to install external packages: ng add "dependency-name"
to get all the commands: ng help
to build application: ng build

COMPONENTS
they are the small parts of an application that can be reused again in some other project.
4 files are generated when a component is created:
1. .html = used for placing
2. .css = used for styling
3. .ts = used for writing logic
4. .spec.ts = unit testing of the component

to place a component inside another
1. in the .ts of the parent component import the component in the import array
2. in .ts file of the component, we have a @Component annotation and inside that we have the selector which is the HTML tag name to be used in the HTML file of the parent component.

NOTE:
we can create a function and call it using a button and using the (click) inside the button
function has to be declared in the .ts file of the component and then the functions can be called from the HTML file

DIRECTIVES
they add more power to DOM elements. its a class that adds additional behaviour to some elements in the application.
directives = ngIf, ngFor, ngStyle etc

3 types of directives = 
1. component directives: most common type of directives. used in component template file. provide the skeleton of the component
2. structural directives: used to manipulate a component like creating, deleting, changing a component etc
3. attribute directives: used to change the feature of the component

PIPES
they are some functions that help format the data when displaying on the HTML page. to use pipes we need to import CommonModule in the imports array of the component.ts file.
some functions performed by pipes are:
1. uppercase: convert everything in the variable to uppercase
2. lowercase: convert everything to lowercase
3. titlecase: "             "     " titlecase

CUSTOM PIPES   
custom pipes are the pipes that a programmer creates. can be created using ng generate pipe <pipe-name> command.
to use the pipe, we need to import the pipe in the imports array of the component and then use name provided in the <pipe-name>.ts file.
write the pipe's logic inside the function in TS file and take in the value / arguments as u like

ATTRIBUTE DIRECTIVES
command: "ng generate directive highlight-text" => we can create a custom directive
2 files are created with their respective .ts and .spec.ts files for logic handling and testing respectively.

by default in a directive, there is a selector which is used to inject the directive in the HTML file.
we take the reference of the element using the directive by importing ElementRef , inject from @angular/core.
in the class, we use the inject function and inside that pass the ElementRef and take the instance of it to call the element tag.
to modify the CSS of prop this.element.nativeElement.style.<property-name>

in the directive annotation, we can also pass the property of host that is used to pass the various events for which the directive shall be invoked.
2 events:
(mouseenter) and (mousleave) their names suggest the property of the event

we can add a input property in the .ts file of the directive and pass the input from HTML file. then we can adjust the behaviour according to the input

DEPENDENCY INJECTION
a dependency is a service that performs a paticular function. we can create custom services and we can call a service from a component.
the advantage of using a service is that this is where the business logic is being handled and where all the server calls are also executed.

the demo service has been created in servics package. one thing to note is that providedIn = root helps to tell that this service can be used by any component in the application

ROUTING
routing is the method of navigating to diff parts of an application. usually there is a reload of the entire page when the user hits a diff route, but angular is single page application meaning that only one time the load occurs and the client has all the files for all the endpoints. after server returns the response, client side routing takes over.
routes are the components that need to be loaded when the user hits the specific component.

routes are defined in the app.routes.ts file.

there mainly 2 types of routes:
1. static routes = one without query parameters
2. dynamic routes = ones with query parameters

route loading strategy:
1. lazy loading: loaded when the user hits a specific endpoint
2. eagerly loading: loaded when the user hits the main page and these components are automatically sent by server

to use routers in the app.ts we import RouterOutlet in app.ts

to use lazy loading we use loadComponent() and loadChildren() and return a promise with import and .then() to resolve that promise and return the component

we can also use redirectTo to redirect a request to another route. note that loadComponent / loadChildren can't be used with redirect attribute

to add title to a page, we can add a property of "title: 'Home Page'"

we can also inject certain dependencies in specific routes so as to let certain routes use some services / dependencies.
there is property of providers which is used to pass a service along with the props required for that service.

nested routes:
routes can be added as a children of components.
on '/product' Product component is displayed
on '/product/info' ProductInfo component is displayed
on '/product/reviews' ProductReviews component is displayed
make sure to include router-outlet HTML tag in the parent component's HTML page

we can add routerLink in the <a /> tag so that the link is added as a child to the path and the URL is called accordingly

Secondary Routes wherein we add a name to the router-outlet so that the specific router-outlet can be called from routes.ts.
using this feature we can call to load a specific router-outlet out of various in the parent component.

we can pass contextual data to the router components by passing it as an input as "routerOutletData" and then injecting this as a dependency in the router-outlet component. we can inject it and pass as a signal to use the data as we like in the component. using this we can pass some data into the routerOutlet

Navigating to another route
1. using routerLink and passing the value as array or string. when we want to pass some dynamic data then we need to use array else we can use strings
2. .navigate(): "using this.router.navigate(<string / array>)" string for literals and array to pass dynamic data.
we can query params by writing the params in JSON format and passing along with array as a JSON
3. .navigateWithUrl(): pass the complete endpoint as a string in the function

Reading Route's state 
we can access the route's information by injecting the ActivatedRoute dependency.
this dependency has a lot of attributes:
1. url: complete literal endpoint of the route
2. data: it contains the data for the route
3. params: observable that contains the params passed in the request specific to it
4. query params: the query parameters passed to query the database by the server

Route redirecting with pathMatch:
pathMatch property helps to tell which part of the route should match with the one mentiond and then where should all these be redirected

1. pathMatch = prefix
suppose i set redirect /news to /blog then:
/news will redirect to /blog
/news/:id will redirect to /blog/:id
/news/item/:id will redirect to /blog/item/:id

2. pathMatch = full
suppose /dashboard will redirect to /abc
then /dashboard/:id will also redirect to /abc only.

FORMS
forms help to enable users to login, update profile and to group data together and perform other data entry tasks

reactive forms: provide direct access to the form model object. hence, reusability, testability, scalability etc improve drastically.
template driven forms: simple scenarios where the form is created using directives, is async.

imp form foundation classes:
1. form control: tracks the status of an individual form component.
2. form collection: tracks the same for a collection of forms
3. form array: tracks the same for a array of forms

the main diff in implementation of reactive-forms and template-drive forms is that formControl instance needs to be created for reactive forms whereas not for template driven forms

NOTE: A FORM MODEL IS A FORM CONTROL INSTANCE

DATA FLOW IN REACTIVE FORMS:
1. view to model (user makes changes on the form from client and they are synced to the model)
a. the user changes the value let's say input tag of a form
b. the form fires an input event.
c. the ControlValueAccessor is listening for all types of events and when the input event is triggered then it fires an observable of valueChanges.
d. this valueChanges observable tells all its subscribers that an "input" event has taken place and notifies all its subs. they accordingly change the value wherever needed

2. model to view (a change in the application triggers the logic to make the same change on the form input)
a. the method whichever is executed calls the .setValue() on the FormControl. 
b. FormControl again calls the valueChanges observable which calls its subscribers and event is notified.
c. the FormControl also tells ControlValueAccessor that a value has been change n the input field is also changed accordingly.

DATA FLOW IN TEMPLATE-DRIVEN FORMS
1. view to model:
a. the user change the value and triggers an input event.
b. this input event triggers the ControlValueAccessor to call the setValue method on the FormControl which calls the valueChanges observable which notifies its subscribers and the event propagates.
c. the ControlValueAccessor also calls viewToModelUpdate() method and NgModel emits a NgModelChange event and it has 2 way binding with Component and hence, updates the value of the component.

2. model to view
a. the component updates the property value bound to NgModel directive. this property is changed by calling ngOnChanges.
b. ngOnChanges queues the task change to set the value of the internal FormControl instance.
c. this value is then updated of the component and triggers the changes in valueChange observable.
d. all the subscribers of this observable are notified at once.

MUTABILITY aspect:
1. in reactive forms: the mutability aspect is very good as every time a change is made, a new data model is created and the unique fields which have changed are updated. this is much faster and we can track the changes using FormControl's observable.
2. in template driven forms: the mutability aspect is less as there is 2 way binding between the component and the template. as the changes are made in component, so are they made in the template.

FORM VALIDATION:
reactive forms: we can define custom validators as functions that can validate a form by checking required fields must be filled, external API can be queried for exsiting username etc.

FORM MODELS:
we can create a new form component using the signal method of the form. this method holds an object that returns the form's data structure.

creating a form model:
we use the form method and in the imports array add FormField. we then create a signal which stores the structure as to how should the form look like. then this is passed inside the form() as a argument and then actual form is created and its value can be stored in var.

note that the form created is a field tree structure, meaning that i can access any value of the form using like "this.loginForm.username" and using {{}} in the HTML to display the same on the HTML page.

we use the dependency of formField and bind it with the input tag to store the input directly in the form's field. note that the signal is the skeleton and all the values of the signal must be present to access. i can't create another attribute to the signal later on. also, to pass optional params we can create an interface mentioning the data types of the props and pass a type as null.

Reading data from a field:
note that every field in the form is a function, hence all the props must have "()" at the last. 